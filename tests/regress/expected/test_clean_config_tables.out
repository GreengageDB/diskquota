-- Test auto cleaning of configuration tables (diskquota.quota_config and
-- diskquota.target) when schema, tablespace or role is dropped.
-- start_ignore
DROP SCHEMA IF EXISTS s1, s2, s3 CASCADE;
NOTICE:  schema "s1" does not exist, skipping
NOTICE:  schema "s2" does not exist, skipping
NOTICE:  schema "s3" does not exist, skipping
DROP ROLE IF EXISTS r1, r2, r3;
NOTICE:  role "r1" does not exist, skipping
NOTICE:  role "r2" does not exist, skipping
NOTICE:  role "r3" does not exist, skipping
DROP TABLESPACE IF EXISTS ts1;
NOTICE:  tablespace "ts1" does not exist, skipping
DROP TABLESPACE IF EXISTS ts2;
NOTICE:  tablespace "ts2" does not exist, skipping
DROP TABLESPACE IF EXISTS ts3;
NOTICE:  tablespace "ts3" does not exist, skipping
-- end_ignore
\! rm -rf /tmp/ts1 /tmp/ts2 /tmp/ts3
TRUNCATE TABLE diskquota.target;
TRUNCATE TABLE diskquota.quota_config;
-- NAMESPACE_QUOTA
CREATE SCHEMA s1;
CREATE SCHEMA s2;
CREATE SCHEMA s3;
SELECT diskquota.set_schema_quota(s, '1GB')
FROM (VALUES('s1'), ('s2'), ('s3')) v(s);
 set_schema_quota 
------------------
 
 
 
(3 rows)

DROP SCHEMA s2;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT n.nspname
FROM diskquota.quota_config c
LEFT JOIN pg_namespace n ON n.oid = c.targetoid
WHERE c.quotatype = 0;
 nspname 
---------
 s1
 s3
(2 rows)

-- ROLE_QUOTA
CREATE ROLE r1;
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE r2;
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE r3;
NOTICE:  resource queue required -- using default resource queue "pg_default"
SELECT diskquota.set_role_quota(r, '100GB')
FROM (VALUES('r1'), ('r2'), ('r3')) v(r);
 set_role_quota 
----------------
 
 
 
(3 rows)

DROP ROLE r2;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT a.rolname
FROM diskquota.quota_config c
LEFT JOIN pg_authid a ON a.oid = c.targetoid
WHERE c.quotatype = 1;
 rolname 
---------
 r1
 r3
(2 rows)

-- TABLESPACE_QUOTA
\! mkdir -p /tmp/ts1
\! mkdir -p /tmp/ts2
\! mkdir -p /tmp/ts3
CREATE TABLESPACE ts1 LOCATION '/tmp/ts1';
CREATE TABLESPACE ts2 LOCATION '/tmp/ts2';
CREATE TABLESPACE ts3 LOCATION '/tmp/ts3';
SELECT diskquota.set_per_segment_quota(ts, '10.0')
FROM (VALUES('ts1'), ('ts2'), ('ts3')) v(ts);
 set_per_segment_quota 
-----------------------
 
 
 
(3 rows)

DROP TABLESPACE ts2;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT s.spcname
FROM diskquota.quota_config c
LEFT JOIN pg_tablespace s ON s.oid = c.targetoid
WHERE c.quotatype = 4;
 spcname 
---------
 ts1
 ts3
(2 rows)

-- NAMESPACE_TABLESPACE_QUOTA
SELECT diskquota.set_schema_tablespace_quota(s, ts, '1GB')
FROM (VALUES ('s1'), ('s3')) AS vs(s), (VALUES ('ts1'), ('ts3')) AS vts(ts);
 set_schema_tablespace_quota 
-----------------------------
 
 
 
 
(4 rows)

DROP SCHEMA s1;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT count() FROM diskquota.quota_config WHERE quotatype = 2;
 count 
-------
     2
(1 row)

SELECT s.spcname, n.nspname
FROM diskquota.target c
LEFT JOIN pg_tablespace s ON s.oid = c.tablespaceoid
LEFT JOIN pg_namespace n ON n.oid = c.primaryoid
WHERE c.quotatype = 2;
 spcname | nspname 
---------+---------
 ts1     | s3
 ts3     | s3
(2 rows)

DROP TABLESPACE ts1;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT count() FROM diskquota.quota_config WHERE quotatype = 2;
 count 
-------
     1
(1 row)

SELECT s.spcname, n.nspname
FROM diskquota.target c
LEFT JOIN pg_tablespace s ON s.oid = c.tablespaceoid
LEFT JOIN pg_namespace n ON n.oid = c.primaryoid
WHERE c.quotatype = 2;
 spcname | nspname 
---------+---------
 ts3     | s3
(1 row)

-- ROLE_TABLESPACE_QUOTA
CREATE TABLESPACE ts1 LOCATION '/tmp/ts1';
SELECT diskquota.set_role_tablespace_quota(r, ts, '1GB')
FROM (VALUES ('r1'), ('r3')) AS vr(r), (VALUES ('ts1'), ('ts3')) AS vts(ts);
 set_role_tablespace_quota 
---------------------------
 
 
 
 
(4 rows)

DROP ROLE r1;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT count() FROM diskquota.quota_config WHERE quotatype = 3;
 count 
-------
     2
(1 row)

SELECT s.spcname, a.rolname
FROM diskquota.target c
LEFT JOIN pg_tablespace s ON s.oid = c.tablespaceoid
LEFT JOIN pg_authid a ON a.oid = c.primaryoid
WHERE c.quotatype = 3;
 spcname | rolname 
---------+---------
 ts1     | r3
 ts3     | r3
(2 rows)

DROP TABLESPACE ts1;
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT count() FROM diskquota.quota_config WHERE quotatype = 3;
 count 
-------
     1
(1 row)

SELECT s.spcname, a.rolname
FROM diskquota.target c
LEFT JOIN pg_tablespace s ON s.oid = c.tablespaceoid
LEFT JOIN pg_authid a ON a.oid = c.primaryoid
WHERE c.quotatype = 3;
 spcname | rolname 
---------+---------
 ts3     | r3
(1 row)

-- Test invalid entries cleaning
TRUNCATE TABLE diskquota.target;
TRUNCATE TABLE diskquota.quota_config;
INSERT INTO diskquota.target VALUES (0, 0, 0, 0);
INSERT INTO diskquota.quota_config VALUES (0, 0, 0, 0);
SELECT diskquota.wait_for_worker_new_epoch();
 wait_for_worker_new_epoch 
---------------------------
 t
(1 row)

SELECT count() FROM diskquota.target;
 count 
-------
     0
(1 row)

SELECT count() FROM diskquota.quota_config;
 count 
-------
     0
(1 row)

-- cleanup
TRUNCATE TABLE diskquota.target;
TRUNCATE TABLE diskquota.quota_config;
DROP SCHEMA s3;
DROP ROLE r3;
DROP TABLESPACE ts3;
\! rm -rf /tmp/ts1 /tmp/ts2 /tmp/ts3
